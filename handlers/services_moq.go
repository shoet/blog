// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package handlers

import (
	"context"
	"github.com/shoet/blog/internal/infrastracture/models"
	"github.com/shoet/blog/internal/options"
	"sync"
)

// Ensure, that BlogManagerMock does implement BlogManager.
// If this is not the case, regenerate this file with moq.
var _ BlogManager = &BlogManagerMock{}

// BlogManagerMock is a mock implementation of BlogManager.
//
//	func TestSomethingThatUsesBlogManager(t *testing.T) {
//
//		// make and configure a mocked BlogManager
//		mockedBlogManager := &BlogManagerMock{
//			AddBlogFunc: func(ctx context.Context, blog *models.Blog) (*models.Blog, error) {
//				panic("mock out the AddBlog method")
//			},
//			DeleteBlogFunc: func(ctx context.Context, id models.BlogId) error {
//				panic("mock out the DeleteBlog method")
//			},
//			ExportFunc: func(ctx context.Context) error {
//				panic("mock out the Export method")
//			},
//			GetBlogFunc: func(ctx context.Context, id models.BlogId) (*models.Blog, error) {
//				panic("mock out the GetBlog method")
//			},
//			ListBlogFunc: func(ctx context.Context, option options.ListBlogOptions) ([]*models.Blog, error) {
//				panic("mock out the ListBlog method")
//			},
//			ListTagsFunc: func(ctx context.Context, option options.ListTagsOptions) ([]*models.Tag, error) {
//				panic("mock out the ListTags method")
//			},
//			PutBlogFunc: func(ctx context.Context, blog *models.Blog) (*models.Blog, error) {
//				panic("mock out the PutBlog method")
//			},
//		}
//
//		// use mockedBlogManager in code that requires BlogManager
//		// and then make assertions.
//
//	}
type BlogManagerMock struct {
	// AddBlogFunc mocks the AddBlog method.
	AddBlogFunc func(ctx context.Context, blog *models.Blog) (*models.Blog, error)

	// DeleteBlogFunc mocks the DeleteBlog method.
	DeleteBlogFunc func(ctx context.Context, id models.BlogId) error

	// ExportFunc mocks the Export method.
	ExportFunc func(ctx context.Context) error

	// GetBlogFunc mocks the GetBlog method.
	GetBlogFunc func(ctx context.Context, id models.BlogId) (*models.Blog, error)

	// ListBlogFunc mocks the ListBlog method.
	ListBlogFunc func(ctx context.Context, option options.ListBlogOptions) ([]*models.Blog, error)

	// ListTagsFunc mocks the ListTags method.
	ListTagsFunc func(ctx context.Context, option options.ListTagsOptions) ([]*models.Tag, error)

	// PutBlogFunc mocks the PutBlog method.
	PutBlogFunc func(ctx context.Context, blog *models.Blog) (*models.Blog, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddBlog holds details about calls to the AddBlog method.
		AddBlog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Blog is the blog argument value.
			Blog *models.Blog
		}
		// DeleteBlog holds details about calls to the DeleteBlog method.
		DeleteBlog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.BlogId
		}
		// Export holds details about calls to the Export method.
		Export []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetBlog holds details about calls to the GetBlog method.
		GetBlog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID models.BlogId
		}
		// ListBlog holds details about calls to the ListBlog method.
		ListBlog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Option is the option argument value.
			Option options.ListBlogOptions
		}
		// ListTags holds details about calls to the ListTags method.
		ListTags []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Option is the option argument value.
			Option options.ListTagsOptions
		}
		// PutBlog holds details about calls to the PutBlog method.
		PutBlog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Blog is the blog argument value.
			Blog *models.Blog
		}
	}
	lockAddBlog    sync.RWMutex
	lockDeleteBlog sync.RWMutex
	lockExport     sync.RWMutex
	lockGetBlog    sync.RWMutex
	lockListBlog   sync.RWMutex
	lockListTags   sync.RWMutex
	lockPutBlog    sync.RWMutex
}

// AddBlog calls AddBlogFunc.
func (mock *BlogManagerMock) AddBlog(ctx context.Context, blog *models.Blog) (*models.Blog, error) {
	if mock.AddBlogFunc == nil {
		panic("BlogManagerMock.AddBlogFunc: method is nil but BlogManager.AddBlog was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Blog *models.Blog
	}{
		Ctx:  ctx,
		Blog: blog,
	}
	mock.lockAddBlog.Lock()
	mock.calls.AddBlog = append(mock.calls.AddBlog, callInfo)
	mock.lockAddBlog.Unlock()
	return mock.AddBlogFunc(ctx, blog)
}

// AddBlogCalls gets all the calls that were made to AddBlog.
// Check the length with:
//
//	len(mockedBlogManager.AddBlogCalls())
func (mock *BlogManagerMock) AddBlogCalls() []struct {
	Ctx  context.Context
	Blog *models.Blog
} {
	var calls []struct {
		Ctx  context.Context
		Blog *models.Blog
	}
	mock.lockAddBlog.RLock()
	calls = mock.calls.AddBlog
	mock.lockAddBlog.RUnlock()
	return calls
}

// DeleteBlog calls DeleteBlogFunc.
func (mock *BlogManagerMock) DeleteBlog(ctx context.Context, id models.BlogId) error {
	if mock.DeleteBlogFunc == nil {
		panic("BlogManagerMock.DeleteBlogFunc: method is nil but BlogManager.DeleteBlog was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  models.BlogId
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteBlog.Lock()
	mock.calls.DeleteBlog = append(mock.calls.DeleteBlog, callInfo)
	mock.lockDeleteBlog.Unlock()
	return mock.DeleteBlogFunc(ctx, id)
}

// DeleteBlogCalls gets all the calls that were made to DeleteBlog.
// Check the length with:
//
//	len(mockedBlogManager.DeleteBlogCalls())
func (mock *BlogManagerMock) DeleteBlogCalls() []struct {
	Ctx context.Context
	ID  models.BlogId
} {
	var calls []struct {
		Ctx context.Context
		ID  models.BlogId
	}
	mock.lockDeleteBlog.RLock()
	calls = mock.calls.DeleteBlog
	mock.lockDeleteBlog.RUnlock()
	return calls
}

// Export calls ExportFunc.
func (mock *BlogManagerMock) Export(ctx context.Context) error {
	if mock.ExportFunc == nil {
		panic("BlogManagerMock.ExportFunc: method is nil but BlogManager.Export was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockExport.Lock()
	mock.calls.Export = append(mock.calls.Export, callInfo)
	mock.lockExport.Unlock()
	return mock.ExportFunc(ctx)
}

// ExportCalls gets all the calls that were made to Export.
// Check the length with:
//
//	len(mockedBlogManager.ExportCalls())
func (mock *BlogManagerMock) ExportCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockExport.RLock()
	calls = mock.calls.Export
	mock.lockExport.RUnlock()
	return calls
}

// GetBlog calls GetBlogFunc.
func (mock *BlogManagerMock) GetBlog(ctx context.Context, id models.BlogId) (*models.Blog, error) {
	if mock.GetBlogFunc == nil {
		panic("BlogManagerMock.GetBlogFunc: method is nil but BlogManager.GetBlog was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  models.BlogId
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetBlog.Lock()
	mock.calls.GetBlog = append(mock.calls.GetBlog, callInfo)
	mock.lockGetBlog.Unlock()
	return mock.GetBlogFunc(ctx, id)
}

// GetBlogCalls gets all the calls that were made to GetBlog.
// Check the length with:
//
//	len(mockedBlogManager.GetBlogCalls())
func (mock *BlogManagerMock) GetBlogCalls() []struct {
	Ctx context.Context
	ID  models.BlogId
} {
	var calls []struct {
		Ctx context.Context
		ID  models.BlogId
	}
	mock.lockGetBlog.RLock()
	calls = mock.calls.GetBlog
	mock.lockGetBlog.RUnlock()
	return calls
}

// ListBlog calls ListBlogFunc.
func (mock *BlogManagerMock) ListBlog(ctx context.Context, option options.ListBlogOptions) ([]*models.Blog, error) {
	if mock.ListBlogFunc == nil {
		panic("BlogManagerMock.ListBlogFunc: method is nil but BlogManager.ListBlog was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Option options.ListBlogOptions
	}{
		Ctx:    ctx,
		Option: option,
	}
	mock.lockListBlog.Lock()
	mock.calls.ListBlog = append(mock.calls.ListBlog, callInfo)
	mock.lockListBlog.Unlock()
	return mock.ListBlogFunc(ctx, option)
}

// ListBlogCalls gets all the calls that were made to ListBlog.
// Check the length with:
//
//	len(mockedBlogManager.ListBlogCalls())
func (mock *BlogManagerMock) ListBlogCalls() []struct {
	Ctx    context.Context
	Option options.ListBlogOptions
} {
	var calls []struct {
		Ctx    context.Context
		Option options.ListBlogOptions
	}
	mock.lockListBlog.RLock()
	calls = mock.calls.ListBlog
	mock.lockListBlog.RUnlock()
	return calls
}

// ListTags calls ListTagsFunc.
func (mock *BlogManagerMock) ListTags(ctx context.Context, option options.ListTagsOptions) ([]*models.Tag, error) {
	if mock.ListTagsFunc == nil {
		panic("BlogManagerMock.ListTagsFunc: method is nil but BlogManager.ListTags was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Option options.ListTagsOptions
	}{
		Ctx:    ctx,
		Option: option,
	}
	mock.lockListTags.Lock()
	mock.calls.ListTags = append(mock.calls.ListTags, callInfo)
	mock.lockListTags.Unlock()
	return mock.ListTagsFunc(ctx, option)
}

// ListTagsCalls gets all the calls that were made to ListTags.
// Check the length with:
//
//	len(mockedBlogManager.ListTagsCalls())
func (mock *BlogManagerMock) ListTagsCalls() []struct {
	Ctx    context.Context
	Option options.ListTagsOptions
} {
	var calls []struct {
		Ctx    context.Context
		Option options.ListTagsOptions
	}
	mock.lockListTags.RLock()
	calls = mock.calls.ListTags
	mock.lockListTags.RUnlock()
	return calls
}

// PutBlog calls PutBlogFunc.
func (mock *BlogManagerMock) PutBlog(ctx context.Context, blog *models.Blog) (*models.Blog, error) {
	if mock.PutBlogFunc == nil {
		panic("BlogManagerMock.PutBlogFunc: method is nil but BlogManager.PutBlog was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Blog *models.Blog
	}{
		Ctx:  ctx,
		Blog: blog,
	}
	mock.lockPutBlog.Lock()
	mock.calls.PutBlog = append(mock.calls.PutBlog, callInfo)
	mock.lockPutBlog.Unlock()
	return mock.PutBlogFunc(ctx, blog)
}

// PutBlogCalls gets all the calls that were made to PutBlog.
// Check the length with:
//
//	len(mockedBlogManager.PutBlogCalls())
func (mock *BlogManagerMock) PutBlogCalls() []struct {
	Ctx  context.Context
	Blog *models.Blog
} {
	var calls []struct {
		Ctx  context.Context
		Blog *models.Blog
	}
	mock.lockPutBlog.RLock()
	calls = mock.calls.PutBlog
	mock.lockPutBlog.RUnlock()
	return calls
}

// Ensure, that AuthManagerMock does implement AuthManager.
// If this is not the case, regenerate this file with moq.
var _ AuthManager = &AuthManagerMock{}

// AuthManagerMock is a mock implementation of AuthManager.
//
//	func TestSomethingThatUsesAuthManager(t *testing.T) {
//
//		// make and configure a mocked AuthManager
//		mockedAuthManager := &AuthManagerMock{
//			LoginFunc: func(ctx context.Context, email string, password string) (string, error) {
//				panic("mock out the Login method")
//			},
//			LoginSessionFunc: func(ctx context.Context, token string) (*models.User, error) {
//				panic("mock out the LoginSession method")
//			},
//		}
//
//		// use mockedAuthManager in code that requires AuthManager
//		// and then make assertions.
//
//	}
type AuthManagerMock struct {
	// LoginFunc mocks the Login method.
	LoginFunc func(ctx context.Context, email string, password string) (string, error)

	// LoginSessionFunc mocks the LoginSession method.
	LoginSessionFunc func(ctx context.Context, token string) (*models.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// Login holds details about calls to the Login method.
		Login []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
			// Password is the password argument value.
			Password string
		}
		// LoginSession holds details about calls to the LoginSession method.
		LoginSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
	}
	lockLogin        sync.RWMutex
	lockLoginSession sync.RWMutex
}

// Login calls LoginFunc.
func (mock *AuthManagerMock) Login(ctx context.Context, email string, password string) (string, error) {
	if mock.LoginFunc == nil {
		panic("AuthManagerMock.LoginFunc: method is nil but AuthManager.Login was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Email    string
		Password string
	}{
		Ctx:      ctx,
		Email:    email,
		Password: password,
	}
	mock.lockLogin.Lock()
	mock.calls.Login = append(mock.calls.Login, callInfo)
	mock.lockLogin.Unlock()
	return mock.LoginFunc(ctx, email, password)
}

// LoginCalls gets all the calls that were made to Login.
// Check the length with:
//
//	len(mockedAuthManager.LoginCalls())
func (mock *AuthManagerMock) LoginCalls() []struct {
	Ctx      context.Context
	Email    string
	Password string
} {
	var calls []struct {
		Ctx      context.Context
		Email    string
		Password string
	}
	mock.lockLogin.RLock()
	calls = mock.calls.Login
	mock.lockLogin.RUnlock()
	return calls
}

// LoginSession calls LoginSessionFunc.
func (mock *AuthManagerMock) LoginSession(ctx context.Context, token string) (*models.User, error) {
	if mock.LoginSessionFunc == nil {
		panic("AuthManagerMock.LoginSessionFunc: method is nil but AuthManager.LoginSession was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockLoginSession.Lock()
	mock.calls.LoginSession = append(mock.calls.LoginSession, callInfo)
	mock.lockLoginSession.Unlock()
	return mock.LoginSessionFunc(ctx, token)
}

// LoginSessionCalls gets all the calls that were made to LoginSession.
// Check the length with:
//
//	len(mockedAuthManager.LoginSessionCalls())
func (mock *AuthManagerMock) LoginSessionCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockLoginSession.RLock()
	calls = mock.calls.LoginSession
	mock.lockLoginSession.RUnlock()
	return calls
}

// Ensure, that StoragerMock does implement Storager.
// If this is not the case, regenerate this file with moq.
var _ Storager = &StoragerMock{}

// StoragerMock is a mock implementation of Storager.
//
//	func TestSomethingThatUsesStorager(t *testing.T) {
//
//		// make and configure a mocked Storager
//		mockedStorager := &StoragerMock{
//			GenerateContentImagePutURLFunc: func(fileName string) (string, string, error) {
//				panic("mock out the GenerateContentImagePutURL method")
//			},
//			GenerateThumbnailPutURLFunc: func(fileName string) (string, string, error) {
//				panic("mock out the GenerateThumbnailPutURL method")
//			},
//		}
//
//		// use mockedStorager in code that requires Storager
//		// and then make assertions.
//
//	}
type StoragerMock struct {
	// GenerateContentImagePutURLFunc mocks the GenerateContentImagePutURL method.
	GenerateContentImagePutURLFunc func(fileName string) (string, string, error)

	// GenerateThumbnailPutURLFunc mocks the GenerateThumbnailPutURL method.
	GenerateThumbnailPutURLFunc func(fileName string) (string, string, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateContentImagePutURL holds details about calls to the GenerateContentImagePutURL method.
		GenerateContentImagePutURL []struct {
			// FileName is the fileName argument value.
			FileName string
		}
		// GenerateThumbnailPutURL holds details about calls to the GenerateThumbnailPutURL method.
		GenerateThumbnailPutURL []struct {
			// FileName is the fileName argument value.
			FileName string
		}
	}
	lockGenerateContentImagePutURL sync.RWMutex
	lockGenerateThumbnailPutURL    sync.RWMutex
}

// GenerateContentImagePutURL calls GenerateContentImagePutURLFunc.
func (mock *StoragerMock) GenerateContentImagePutURL(fileName string) (string, string, error) {
	if mock.GenerateContentImagePutURLFunc == nil {
		panic("StoragerMock.GenerateContentImagePutURLFunc: method is nil but Storager.GenerateContentImagePutURL was just called")
	}
	callInfo := struct {
		FileName string
	}{
		FileName: fileName,
	}
	mock.lockGenerateContentImagePutURL.Lock()
	mock.calls.GenerateContentImagePutURL = append(mock.calls.GenerateContentImagePutURL, callInfo)
	mock.lockGenerateContentImagePutURL.Unlock()
	return mock.GenerateContentImagePutURLFunc(fileName)
}

// GenerateContentImagePutURLCalls gets all the calls that were made to GenerateContentImagePutURL.
// Check the length with:
//
//	len(mockedStorager.GenerateContentImagePutURLCalls())
func (mock *StoragerMock) GenerateContentImagePutURLCalls() []struct {
	FileName string
} {
	var calls []struct {
		FileName string
	}
	mock.lockGenerateContentImagePutURL.RLock()
	calls = mock.calls.GenerateContentImagePutURL
	mock.lockGenerateContentImagePutURL.RUnlock()
	return calls
}

// GenerateThumbnailPutURL calls GenerateThumbnailPutURLFunc.
func (mock *StoragerMock) GenerateThumbnailPutURL(fileName string) (string, string, error) {
	if mock.GenerateThumbnailPutURLFunc == nil {
		panic("StoragerMock.GenerateThumbnailPutURLFunc: method is nil but Storager.GenerateThumbnailPutURL was just called")
	}
	callInfo := struct {
		FileName string
	}{
		FileName: fileName,
	}
	mock.lockGenerateThumbnailPutURL.Lock()
	mock.calls.GenerateThumbnailPutURL = append(mock.calls.GenerateThumbnailPutURL, callInfo)
	mock.lockGenerateThumbnailPutURL.Unlock()
	return mock.GenerateThumbnailPutURLFunc(fileName)
}

// GenerateThumbnailPutURLCalls gets all the calls that were made to GenerateThumbnailPutURL.
// Check the length with:
//
//	len(mockedStorager.GenerateThumbnailPutURLCalls())
func (mock *StoragerMock) GenerateThumbnailPutURLCalls() []struct {
	FileName string
} {
	var calls []struct {
		FileName string
	}
	mock.lockGenerateThumbnailPutURL.RLock()
	calls = mock.calls.GenerateThumbnailPutURL
	mock.lockGenerateThumbnailPutURL.RUnlock()
	return calls
}
