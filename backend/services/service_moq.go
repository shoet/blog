// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package services

import (
	"context"
	"github.com/shoet/blog/models"
	"sync"
)

// Ensure, that JWTerMock does implement JWTer.
// If this is not the case, regenerate this file with moq.
var _ JWTer = &JWTerMock{}

// JWTerMock is a mock implementation of JWTer.
//
//	func TestSomethingThatUsesJWTer(t *testing.T) {
//
//		// make and configure a mocked JWTer
//		mockedJWTer := &JWTerMock{
//			GenerateTokenFunc: func(ctx context.Context, u *models.User) (string, error) {
//				panic("mock out the GenerateToken method")
//			},
//			VerifyTokenFunc: func(ctx context.Context, token string) (models.UserId, error) {
//				panic("mock out the VerifyToken method")
//			},
//		}
//
//		// use mockedJWTer in code that requires JWTer
//		// and then make assertions.
//
//	}
type JWTerMock struct {
	// GenerateTokenFunc mocks the GenerateToken method.
	GenerateTokenFunc func(ctx context.Context, u *models.User) (string, error)

	// VerifyTokenFunc mocks the VerifyToken method.
	VerifyTokenFunc func(ctx context.Context, token string) (models.UserId, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateToken holds details about calls to the GenerateToken method.
		GenerateToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// U is the u argument value.
			U *models.User
		}
		// VerifyToken holds details about calls to the VerifyToken method.
		VerifyToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
	}
	lockGenerateToken sync.RWMutex
	lockVerifyToken   sync.RWMutex
}

// GenerateToken calls GenerateTokenFunc.
func (mock *JWTerMock) GenerateToken(ctx context.Context, u *models.User) (string, error) {
	if mock.GenerateTokenFunc == nil {
		panic("JWTerMock.GenerateTokenFunc: method is nil but JWTer.GenerateToken was just called")
	}
	callInfo := struct {
		Ctx context.Context
		U   *models.User
	}{
		Ctx: ctx,
		U:   u,
	}
	mock.lockGenerateToken.Lock()
	mock.calls.GenerateToken = append(mock.calls.GenerateToken, callInfo)
	mock.lockGenerateToken.Unlock()
	return mock.GenerateTokenFunc(ctx, u)
}

// GenerateTokenCalls gets all the calls that were made to GenerateToken.
// Check the length with:
//
//	len(mockedJWTer.GenerateTokenCalls())
func (mock *JWTerMock) GenerateTokenCalls() []struct {
	Ctx context.Context
	U   *models.User
} {
	var calls []struct {
		Ctx context.Context
		U   *models.User
	}
	mock.lockGenerateToken.RLock()
	calls = mock.calls.GenerateToken
	mock.lockGenerateToken.RUnlock()
	return calls
}

// VerifyToken calls VerifyTokenFunc.
func (mock *JWTerMock) VerifyToken(ctx context.Context, token string) (models.UserId, error) {
	if mock.VerifyTokenFunc == nil {
		panic("JWTerMock.VerifyTokenFunc: method is nil but JWTer.VerifyToken was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockVerifyToken.Lock()
	mock.calls.VerifyToken = append(mock.calls.VerifyToken, callInfo)
	mock.lockVerifyToken.Unlock()
	return mock.VerifyTokenFunc(ctx, token)
}

// VerifyTokenCalls gets all the calls that were made to VerifyToken.
// Check the length with:
//
//	len(mockedJWTer.VerifyTokenCalls())
func (mock *JWTerMock) VerifyTokenCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockVerifyToken.RLock()
	calls = mock.calls.VerifyToken
	mock.lockVerifyToken.RUnlock()
	return calls
}

// Ensure, that KVSerMock does implement KVSer.
// If this is not the case, regenerate this file with moq.
var _ KVSer = &KVSerMock{}

// KVSerMock is a mock implementation of KVSer.
//
//	func TestSomethingThatUsesKVSer(t *testing.T) {
//
//		// make and configure a mocked KVSer
//		mockedKVSer := &KVSerMock{
//			LoadFunc: func(ctx context.Context, key string) (string, error) {
//				panic("mock out the Load method")
//			},
//			SaveFunc: func(ctx context.Context, key string, value string) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedKVSer in code that requires KVSer
//		// and then make assertions.
//
//	}
type KVSerMock struct {
	// LoadFunc mocks the Load method.
	LoadFunc func(ctx context.Context, key string) (string, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, key string, value string) error

	// calls tracks calls to the methods.
	calls struct {
		// Load holds details about calls to the Load method.
		Load []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
		}
	}
	lockLoad sync.RWMutex
	lockSave sync.RWMutex
}

// Load calls LoadFunc.
func (mock *KVSerMock) Load(ctx context.Context, key string) (string, error) {
	if mock.LoadFunc == nil {
		panic("KVSerMock.LoadFunc: method is nil but KVSer.Load was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockLoad.Lock()
	mock.calls.Load = append(mock.calls.Load, callInfo)
	mock.lockLoad.Unlock()
	return mock.LoadFunc(ctx, key)
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//
//	len(mockedKVSer.LoadCalls())
func (mock *KVSerMock) LoadCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockLoad.RLock()
	calls = mock.calls.Load
	mock.lockLoad.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *KVSerMock) Save(ctx context.Context, key string, value string) error {
	if mock.SaveFunc == nil {
		panic("KVSerMock.SaveFunc: method is nil but KVSer.Save was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, key, value)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedKVSer.SaveCalls())
func (mock *KVSerMock) SaveCalls() []struct {
	Ctx   context.Context
	Key   string
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value string
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}
